{"ast":null,"code":"import { isArray, isPlainObject, isSymbol } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject) {\n  var propType = originalObject.propertyIsEnumerable(key) ? 'enumerable' : 'nonenumerable';\n  if (propType === 'enumerable') carry[key] = newVal;\n\n  if (propType === 'nonenumerable') {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nfunction mergeRecursively(origin, newComer, extensions) {\n  // work directly on newComer if its not an object\n  if (!isPlainObject(newComer)) {\n    // extend merge rules\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newComer = extend(origin, newComer);\n      });\n    }\n\n    return newComer;\n  } // define newObject to merge all values upon\n\n\n  var newObject = {};\n\n  if (isPlainObject(origin)) {\n    var props_1 = Object.getOwnPropertyNames(origin);\n    var symbols_1 = Object.getOwnPropertySymbols(origin);\n    newObject = props_1.concat(symbols_1).reduce(function (carry, key) {\n      // @ts-ignore\n      var targetVal = origin[key];\n\n      if (!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) {\n        assignProp(carry, key, targetVal, origin);\n      }\n\n      return carry;\n    }, {});\n  }\n\n  var props = Object.getOwnPropertyNames(newComer);\n  var symbols = Object.getOwnPropertySymbols(newComer);\n  var result = props.concat(symbols).reduce(function (carry, key) {\n    // re-define the origin and newComer as targetVal and newVal\n    var newVal = newComer[key];\n    var targetVal = isPlainObject(origin) ? // @ts-ignore\n    origin[key] : undefined; // extend merge rules\n\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newVal = extend(targetVal, newVal);\n      });\n    } // When newVal is an object do the merge recursively\n\n\n    if (targetVal !== undefined && isPlainObject(newVal)) {\n      newVal = mergeRecursively(targetVal, newVal, extensions);\n    }\n\n    assignProp(carry, key, newVal, newComer);\n    return carry;\n  }, newObject);\n  return result;\n}\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\n\n\nfunction merge(origin) {\n  var newComers = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    newComers[_i - 1] = arguments[_i];\n  }\n\n  var extensions = null;\n  var base = origin;\n\n  if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\n    base = {};\n    extensions = origin.extensions;\n  }\n\n  return newComers.reduce(function (result, newComer) {\n    return mergeRecursively(result, newComer, extensions);\n  }, base);\n}\n\nfunction concatArrays(originVal, newVal) {\n  if (isArray(originVal) && isArray(newVal)) {\n    // concat logic\n    return originVal.concat(newVal);\n  }\n\n  return newVal; // always return newVal as fallback!!\n}\n\nexport default merge;\nexport { merge, concatArrays };","map":{"version":3,"sources":["/Users/weilyuwang/Documents/crown-clothing/node_modules/merge-anything/dist/index.esm.js"],"names":["isArray","isPlainObject","isSymbol","assignProp","carry","key","newVal","originalObject","propType","propertyIsEnumerable","Object","defineProperty","value","enumerable","writable","configurable","mergeRecursively","origin","newComer","extensions","forEach","extend","newObject","props_1","getOwnPropertyNames","symbols_1","getOwnPropertySymbols","concat","reduce","targetVal","includes","props","symbols","result","undefined","merge","newComers","_i","arguments","length","base","keys","concatArrays","originVal"],"mappings":"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","sourcesContent":["import { isArray, isPlainObject, isSymbol } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject) {\r\n    var propType = originalObject.propertyIsEnumerable(key)\r\n        ? 'enumerable'\r\n        : 'nonenumerable';\r\n    if (propType === 'enumerable')\r\n        carry[key] = newVal;\r\n    if (propType === 'nonenumerable') {\r\n        Object.defineProperty(carry, key, {\r\n            value: newVal,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\nfunction mergeRecursively(origin, newComer, extensions) {\r\n    // work directly on newComer if its not an object\r\n    if (!isPlainObject(newComer)) {\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newComer = extend(origin, newComer);\r\n            });\r\n        }\r\n        return newComer;\r\n    }\r\n    // define newObject to merge all values upon\r\n    var newObject = {};\r\n    if (isPlainObject(origin)) {\r\n        var props_1 = Object.getOwnPropertyNames(origin);\r\n        var symbols_1 = Object.getOwnPropertySymbols(origin);\r\n        newObject = props_1.concat(symbols_1).reduce(function (carry, key) {\r\n            // @ts-ignore\r\n            var targetVal = origin[key];\r\n            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||\r\n                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {\r\n                assignProp(carry, key, targetVal, origin);\r\n            }\r\n            return carry;\r\n        }, {});\r\n    }\r\n    var props = Object.getOwnPropertyNames(newComer);\r\n    var symbols = Object.getOwnPropertySymbols(newComer);\r\n    var result = props.concat(symbols).reduce(function (carry, key) {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        var newVal = newComer[key];\r\n        var targetVal = (isPlainObject(origin))\r\n            // @ts-ignore\r\n            ? origin[key]\r\n            : undefined;\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newVal = extend(targetVal, newVal);\r\n            });\r\n        }\r\n        // When newVal is an object do the merge recursively\r\n        if (targetVal !== undefined && isPlainObject(newVal)) {\r\n            newVal = mergeRecursively(targetVal, newVal, extensions);\r\n        }\r\n        assignProp(carry, key, newVal, newComer);\r\n        return carry;\r\n    }, newObject);\r\n    return result;\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\r\nfunction merge(origin) {\r\n    var newComers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        newComers[_i - 1] = arguments[_i];\r\n    }\r\n    var extensions = null;\r\n    var base = origin;\r\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\r\n        base = {};\r\n        extensions = origin.extensions;\r\n    }\r\n    return newComers.reduce(function (result, newComer) {\r\n        return mergeRecursively(result, newComer, extensions);\r\n    }, base);\r\n}\n\nfunction concatArrays(originVal, newVal) {\r\n    if (isArray(originVal) && isArray(newVal)) {\r\n        // concat logic\r\n        return originVal.concat(newVal);\r\n    }\r\n    return newVal; // always return newVal as fallback!!\r\n}\n\nexport default merge;\nexport { merge, concatArrays };\n"]},"metadata":{},"sourceType":"module"}